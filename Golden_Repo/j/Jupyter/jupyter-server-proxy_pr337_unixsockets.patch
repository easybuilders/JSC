diff -Naur jupyter-server-proxy-3.2.1.orig/jupyter_server_proxy/config.py jupyter-server-proxy-3.2.1/jupyter_server_proxy/config.py
--- jupyter-server-proxy-3.2.1.orig/jupyter_server_proxy/config.py      2021-08-16 19:38:33.440690000 +0200
+++ jupyter-server-proxy-3.2.1/jupyter_server_proxy/config.py   2021-08-16 19:11:07.061678000 +0200
@@ -17,7 +17,7 @@
 except ImportError:
     from .utils import Callable
 
-def _make_serverproxy_handler(name, command, environment, timeout, absolute_url, port, mappath, request_headers_override, rewrite_response):
+def _make_serverproxy_handler(name, command, environment, timeout, absolute_url, port, unix, mappath, request_headers_override, rewrite_response):
     """
     Create a SuperviseAndProxyHandler subclass with given parameters
     """
@@ -29,6 +29,7 @@ def __init__(self, *args, **kwargs):
             self.proxy_base = name
             self.absolute_url = absolute_url
             self.requested_port = port
+            self.unix_sock = unix
             self.mappath = mappath
             self.rewrite_response = rewrite_response
 
@@ -99,6 +100,7 @@ def make_handlers(base_url, server_processes):
             sp.timeout,
             sp.absolute_url,
             sp.port,
+            sp.unix,
             sp.mappath,
             sp.request_headers_override,
             sp.rewrite_response,
@@ -113,7 +115,7 @@ def make_handlers(base_url, server_processes):
 
 LauncherEntry = namedtuple('LauncherEntry', ['enabled', 'icon_path', 'title', 'path_info'])
 ServerProcess = namedtuple('ServerProcess', [
-    'name', 'command', 'environment', 'timeout', 'absolute_url', 'port',
+    'name', 'command', 'environment', 'timeout', 'absolute_url', 'port', 'unix',
     'mappath', 'launcher_entry', 'new_browser_tab', 'request_headers_override', 'rewrite_response',
 ])
 
@@ -126,6 +128,7 @@ def make_server_process(name, server_process_config, serverproxy_config):
         timeout=server_process_config.get('timeout', 5),
         absolute_url=server_process_config.get('absolute_url', False),
         port=server_process_config.get('port', 0),
+        unix=server_process_config.get('unix', False),
         mappath=server_process_config.get('mappath', {}),
         launcher_entry=LauncherEntry(
             enabled=le.get('enabled', True),
diff -Naur jupyter-server-proxy-3.2.1.orig/jupyter_server_proxy/handlers.py jupyter-server-proxy-3.2.1/jupyter_server_proxy/handlers.py
--- jupyter-server-proxy-3.2.1.orig/jupyter_server_proxy/handlers.py      2021-08-16 19:38:33.440690000 +0200
+++ jupyter-server-proxy-3.2.1/jupyter_server_proxy/handlers.py   2021-08-16 19:11:07.061678000 +0200
@@ -11,14 +11,17 @@
 import aiohttp
 from asyncio import Lock
 from copy import copy
+from tempfile import mkdtemp
 
 from tornado import gen, web, httpclient, httputil, process, websocket, ioloop, version_info
+from tornado.simple_httpclient import SimpleAsyncHTTPClient
 
 from jupyter_server.utils import ensure_async, url_path_join
 from jupyter_server.base.handlers import JupyterHandler, utcnow
 from traitlets.traitlets import HasTraits
 from traitlets import Bytes, Dict, Instance, Integer, Unicode, Union, default, observe
 
+from .unixsock import UnixResolver
 from .utils import call_with_asked_args
 from .websocket import WebSocketHandlerMixin, pingable_ws_connect
 from simpervisor import SupervisedProcess
@@ -265,6 +268,11 @@ def _check_host_allowlist(self, host):
         else:
             return host in self.host_allowlist
 
+    @staticmethod
+    def is_unix_sock(port):
+        """Distinguish Unix socket path from numeric TCP port"""
+        return isinstance(port, (str, bytes)) and not port.isdigit()
+
     @web.authenticated
     async def proxy(self, host, port, proxied_path):
         '''
@@ -298,7 +306,13 @@ async def proxy(self, host, port, proxied_path):
             else:
                 body = None
 
-        client = httpclient.AsyncHTTPClient()
+        if self.is_unix_sock(port):
+            # Port points to a Unix domain socket
+            self.log.debug("Making client for Unix socket %r", port)
+            assert host == 'localhost', "Unix sockets only possible on localhost"
+            client = SimpleAsyncHTTPClient(resolver=UnixResolver(port))
+        else:
+            client = httpclient.AsyncHTTPClient()
 
         req = self._build_proxy_request(host, port, proxied_path, body)
         self.log.debug(f"Proxying request to {req.url}")
@@ -557,6 +571,7 @@ class SuperviseAndProxyHandler(LocalProxyHandler):
 
     def __init__(self, *args, **kwargs):
         self.requested_port = 0
+        self.unix_sock = False
         self.mappath = {}
         super().__init__(*args, **kwargs)
 
@@ -574,10 +589,14 @@ def port(self):
         application
         """
         if 'port' not in self.state:
-            sock = socket.socket()
-            sock.bind(('', self.requested_port))
-            self.state['port'] = sock.getsockname()[1]
-            sock.close()
+            if self.unix_sock:
+                sock_dir = mkdtemp(prefix='jupyter-server-proxy-')
+                self.state['port'] = os.path.join(sock_dir, 'socket')
+            else:
+                sock = socket.socket()
+                sock.bind(('', self.requested_port))
+                self.state['port'] = sock.getsockname()[1]
+                sock.close()
         return self.state['port']
 
     def get_cwd(self):
@@ -600,8 +619,13 @@ def get_timeout(self):
         return 5
 
     async def _http_ready_func(self, p):
-        url = 'http://localhost:{}'.format(self.port)
-        async with aiohttp.ClientSession() as session:
+        if self.is_unix_sock(self.port):
+            url = 'http://localhost'
+            connector = aiohttp.UnixConnector(self.port)
+        else:
+            url = 'http://localhost:{}'.format(self.port)
+            connector = None  # Default, TCP connector
+        async with aiohttp.ClientSession(connector=connector) as session:
             try:
                 async with session.get(url, allow_redirects=False) as resp:
                     # We only care if we get back *any* response, not just 200
@@ -648,6 +672,10 @@ async def ensure_process(self):
                     del self.state['proc']
                     raise
 
+    def get_client_uri(self, protocol, host, port, proxied_path):
+        if self.is_unix_sock(port):
+            port = 0   # Unix socket - port won't be used
+        return super().get_client_uri(protocol, host, port, proxied_path)
 
     @web.authenticated
     async def proxy(self, port, path):
@@ -668,6 +696,10 @@ async def http_get(self, path):
         return await ensure_async(self.proxy(self.port, path))
 
     async def open(self, path):
+        if self.is_unix_sock(self.port):
+            self.set_status(501)
+            self.write("Proxying websockets on a Unix socket is not supported yet")
+            return
         await self.ensure_process()
         return await super().open(self.port, path)
 
diff -Naur jupyter-server-proxy-3.2.1.orig/jupyter_server_proxy/unixsock.py jupyter-server-proxy-3.2.1/jupyter_server_proxy/unixsock.py
new file mode 100644
index 00000000..fe3bfcdb
--- /dev/null
+++ jupyter-server-proxy-3.2.1/jupyter_server_proxy/unixsock.py
@@ -0,0 +1,10 @@
+import socket
+from tornado.netutil import Resolver
+
+
+class UnixResolver(Resolver):
+    def initialize(self, socket_path):
+        self.socket_path = socket_path
+
+    async def resolve(self, host, port, *args, **kwargs):
+        return [(socket.AF_UNIX, self.socket_path)]

