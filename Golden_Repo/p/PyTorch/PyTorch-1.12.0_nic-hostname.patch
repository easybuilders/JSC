diff -ruN a/torch/distributed/elastic/agent/server/api.py b/torch/distributed/elastic/agent/server/api.py
--- a/torch/distributed/elastic/agent/server/api.py	2023-02-06 13:21:33.000000000 +0100
+++ b/torch/distributed/elastic/agent/server/api.py	2023-02-06 14:49:52.309003092 +0100
@@ -8,6 +8,7 @@
 
 import abc
 import functools
+import ipaddress
 import json
 import os
 import signal
@@ -60,6 +61,8 @@
                      if not specified then will chose a random free port
         master_addr: fixed master_addr to run the c10d store on rank 0
                      if not specified then will chose hostname on agent rank 0
+        endpoint: original endpoint that is discarded when the static
+                  rendezvous backend is specified
         redirects: redirect std streams to a file,
                    selectively redirect for a particular
                    local rank by passing a map
@@ -80,6 +83,7 @@
     monitor_interval: float = 30.0
     master_port: Optional[int] = None
     master_addr: Optional[str] = None
+    endpoint: str = ''
     redirects: Union[Std, Dict[int, Std]] = Std.NONE
     tee: Union[Std, Dict[int, Std]] = Std.NONE
 
@@ -381,8 +385,27 @@
     raise RuntimeError("Failed to create a socket")
 
 
-def _get_fq_hostname() -> str:
-    return socket.getfqdn(socket.gethostname())
+def _get_fq_hostname(master_addr: Optional[str], endpoint: str) -> str:
+    if master_addr:
+        return master_addr
+
+    # `master_addr` is None when we don't have the "static" rendezvous backend.
+    # `endpoint` may not be given (i.e. it is an empty string); then
+    # we have to fall back to `socket.gethostname`.
+    if not endpoint:
+        return socket.getfqdn(socket.gethostname())
+
+    host = rdzv.utils.parse_rendezvous_endpoint(endpoint, default_port=-1)[0]
+    try:
+        ipaddress.ip_address(host)
+        is_ip = True
+    except ValueError:
+        is_ip = False
+
+    if is_ip:
+        return socket.gethostbyaddr(host)[0]
+    else:
+        return socket.getfqdn(host)
 
 
 class ElasticAgent(abc.ABC):
@@ -504,15 +527,17 @@
 
     @staticmethod
     def _set_master_addr_port(
-        store: Store, master_addr: Optional[str], master_port: Optional[int]
+            store: Store,
+            master_addr: Optional[str],
+            master_port: Optional[int],
+            endpoint: str,
     ):
         if master_port is None:
             sock = _get_socket_with_port()
             with closing(sock):
                 master_port = sock.getsockname()[1]
 
-        if master_addr is None:
-            master_addr = _get_fq_hostname()
+        master_addr = _get_fq_hostname(master_addr, endpoint)
 
         store.set("MASTER_ADDR", master_addr.encode(encoding="UTF-8"))
         store.set("MASTER_PORT", str(master_port).encode(encoding="UTF-8"))
@@ -545,7 +570,9 @@
         worker_group.group_world_size = group_world_size
 
         if group_rank == 0:
-            self._set_master_addr_port(store, spec.master_addr, spec.master_port)
+            self._set_master_addr_port(
+                store, spec.master_addr, spec.master_port, spec.endpoint
+            )
         master_addr, master_port = self._get_master_addr_port(store)
         restart_count = spec.max_restarts - self._remaining_restarts
 
@@ -781,7 +808,7 @@
             "group_rank": wg.group_rank,
             "worker_id": worker_id,
             "role": spec.role,
-            "hostname": _get_fq_hostname(),
+            "hostname": _get_fq_hostname(spec.master_addr, spec.endpoint),
             "state": state,
             "total_run_time": self._total_execution_time,
             "rdzv_backend": spec.rdzv_handler.get_backend(),
diff -ruN a/torch/distributed/elastic/rendezvous/utils.py b/torch/distributed/elastic/rendezvous/utils.py
--- a/torch/distributed/elastic/rendezvous/utils.py	2023-02-06 13:21:33.000000000 +0100
+++ b/torch/distributed/elastic/rendezvous/utils.py	2023-02-06 14:52:10.124904154 +0100
@@ -4,15 +4,48 @@
 # This source code is licensed under the BSD-style license found in the
 # LICENSE file in the root directory of this source tree.
 
+import fcntl
 import ipaddress
 import random
 import re
 import socket
+import struct
 import time
 import weakref
 from datetime import timedelta
 from threading import Event, Thread
-from typing import Any, Callable, Dict, Optional, Tuple, Union
+from typing import Any, Callable, Dict, List, Optional, Tuple, Union
+
+
+
+# From https://stackoverflow.com/a/27494105.
+def nic_ip_address(nic_name):
+    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+    return socket.inet_ntoa(fcntl.ioctl(
+        s.fileno(),
+        0x8915,  # SIOCGIFADDR
+        struct.pack('256s', nic_name[:15].encode("UTF-8"))
+    )[20:24])
+
+
+# Adapted from https://stackoverflow.com/a/27494105.
+def nic_info() -> List[Tuple[str, str]]:
+    """Return a list of tuples containing each NIC's hostname and its IPv4."""
+    nics: List[Tuple[str, str]] = []
+    try:
+        if_nameindex = socket.if_nameindex()
+    except OSError:
+        return nics
+
+    for (_, nic_name) in if_nameindex:
+        try:
+            ip_addr = nic_ip_address(nic_name)
+        except OSError:
+            continue
+
+        hostname = socket.gethostbyaddr(ip_addr)[0]
+        nics.append((hostname, ip_addr))
+    return nics
 
 
 def _parse_rendezvous_config(config_str: str) -> Dict[str, str]:
@@ -130,18 +163,26 @@
     if host == this_host:
         return True
 
+    host_fqdn = socket.getfqdn(host)
     addr_list = socket.getaddrinfo(
         this_host, None, proto=socket.IPPROTO_TCP, flags=socket.AI_CANONNAME
     )
     for addr_info in addr_list:
         # If we have an FQDN in the addr_info, compare it to `host`.
-        if addr_info[3] and addr_info[3] == host:
+        if addr_info[3] and (addr_info[3] == host or addr_info[3] == host_fqdn):
             return True
         # Otherwise if `host` represents an IP address, compare it to our IP
         # address.
         if addr and addr_info[4][0] == str(addr):
             return True
 
+    for (nic_host, nic_addr) in nic_info():
+        if (
+                nic_host == host or nic_host == host_fqdn
+                or addr and nic_addr == str(addr)
+        ):
+            return True
+
     return False
 
