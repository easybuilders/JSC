From 73c4cfd820ed14736c034e77b6cbe33ddbb74110 Mon Sep 17 00:00:00 2001
From: janEbert <janpublicebert@posteo.net>
Date: Tue, 12 Jul 2022 10:58:18 +0200
Subject: [PATCH 1/3] Check all NIC hostnames for master host matching

Previously, these were not included, leading to timeouts as no process
assumed the root role.

Ref #73656, first error.
---
 torch/distributed/elastic/rendezvous/utils.py | 37 +++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/torch/distributed/elastic/rendezvous/utils.py b/torch/distributed/elastic/rendezvous/utils.py
index 14158e8bc708..b838398549d1 100644
--- a/torch/distributed/elastic/rendezvous/utils.py
+++ b/torch/distributed/elastic/rendezvous/utils.py
@@ -4,10 +4,12 @@
 # This source code is licensed under the BSD-style license found in the
 # LICENSE file in the root directory of this source tree.
 
+import fcntl
 import ipaddress
 import random
 import re
 import socket
+import struct
 import time
 import weakref
 from datetime import timedelta
@@ -16,6 +18,37 @@
 
 __all__ = ['parse_rendezvous_endpoint']
 
+
+# From https://stackoverflow.com/a/27494105.
+def nic_ip_address(nic_name):
+    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
+    return socket.inet_ntoa(fcntl.ioctl(
+        s.fileno(),
+        0x8915,  # SIOCGIFADDR
+        struct.pack('256s', nic_name[:15].encode("UTF-8"))
+    )[20:24])
+
+
+# Adapted from https://stackoverflow.com/a/27494105.
+def nic_info():
+    """Return a list of tuples containing each NIC's hostname and its IPv4."""
+    nics = []
+    try:
+        if_nameindex = socket.if_nameindex()
+    except OSError:
+        return nics
+
+    for (_, nic_name) in if_nameindex:
+        try:
+            ip_addr = nic_ip_address(nic_name)
+        except OSError:
+            continue
+
+        hostname = socket.gethostbyaddr(ip_addr)[0]
+        nics.append((hostname, ip_addr))
+    return nics
+
+
 def _parse_rendezvous_config(config_str: str) -> Dict[str, str]:
     """Extracts key-value pairs from a rendezvous configuration string.
 
@@ -143,6 +176,10 @@ def _matches_machine_hostname(host: str) -> bool:
         if addr and addr_info[4][0] == str(addr):
             return True
 
+    for (nic_host, nic_addr) in nic_info():
+        if nic_host == host or addr and nic_addr == str(addr):
+            return True
+
     return False
 
 

From 47945806c1dd12fd1e5a8a4adcd88fbd5780f00a Mon Sep 17 00:00:00 2001
From: janEbert <janpublicebert@posteo.net>
Date: Tue, 12 Jul 2022 11:04:21 +0200
Subject: [PATCH 2/3] Handle getting hostname of specified NIC

`_get_fq_hostname` previously returned the fully qualified version of
`socket.gethostname()`. This ignored the possibility of other NIC's
hostnames being supplied as endpoints, leading to possible deadlocks.

We now try to use more available information to get a matching hostname.
This includes keeping the original `--rdzv_endpoint` as a spec variable.
That way, we can refer back to it in order to have more options for
getting the used NIC's hostname.

Ref #73656, second error.
---
 torch/distributed/elastic/agent/server/api.py | 41 +++++++++++++++----
 torch/distributed/launcher/api.py             |  1 +
 2 files changed, 35 insertions(+), 7 deletions(-)

diff --git a/torch/distributed/elastic/agent/server/api.py b/torch/distributed/elastic/agent/server/api.py
index 259632869d43..39ffedea89ba 100644
--- a/torch/distributed/elastic/agent/server/api.py
+++ b/torch/distributed/elastic/agent/server/api.py
@@ -8,6 +8,7 @@
 
 import abc
 import functools
+import ipaddress
 import json
 import os
 import signal
@@ -60,6 +61,8 @@ class WorkerSpec:
                      if not specified then will chose a random free port
         master_addr: fixed master_addr to run the c10d store on rank 0
                      if not specified then will chose hostname on agent rank 0
+        endpoint: original endpoint that is discarded when the static
+                  rendezvous backend is specified
         redirects: redirect std streams to a file,
                    selectively redirect for a particular
                    local rank by passing a map
@@ -80,6 +83,7 @@ class WorkerSpec:
     monitor_interval: float = 30.0
     master_port: Optional[int] = None
     master_addr: Optional[str] = None
+    endpoint: str = ''
     redirects: Union[Std, Dict[int, Std]] = Std.NONE
     tee: Union[Std, Dict[int, Std]] = Std.NONE
 
@@ -381,8 +385,27 @@ def _get_socket_with_port() -> socket.socket:
     raise RuntimeError("Failed to create a socket")
 
 
-def _get_fq_hostname() -> str:
-    return socket.getfqdn(socket.gethostname())
+def _get_fq_hostname(master_addr: Optional[str], endpoint: str) -> str:
+    if master_addr:
+        return master_addr
+
+    # `master_addr` is None when we don't have the "static" rendezvous backend.
+    # `endpoint` may not be given (i.e. it is an empty string); then
+    # we have to fall back to `socket.gethostname`.
+    if not endpoint:
+        return socket.getfqdn(socket.gethostname())
+
+    host = rdzv.utils.parse_rendezvous_endpoint(endpoint, default_port=-1)[0]
+    try:
+        ipaddress.ip_address(host)
+        is_ip = True
+    except ValueError:
+        is_ip = False
+
+    if is_ip:
+        return socket.gethostbyaddr(host)[0]
+    else:
+        return socket.getfqdn(host)
 
 
 class ElasticAgent(abc.ABC):
@@ -504,15 +527,17 @@ def _shutdown(self, death_sig: signal.Signals = signal.SIGTERM) -> None:
 
     @staticmethod
     def _set_master_addr_port(
-        store: Store, master_addr: Optional[str], master_port: Optional[int]
+            store: Store,
+            master_addr: Optional[str],
+            master_port: Optional[int],
+            endpoint: str,
     ):
         if master_port is None:
             sock = _get_socket_with_port()
             with closing(sock):
                 master_port = sock.getsockname()[1]
 
-        if master_addr is None:
-            master_addr = _get_fq_hostname()
+        master_addr = _get_fq_hostname(master_addr, endpoint)
 
         store.set("MASTER_ADDR", master_addr.encode(encoding="UTF-8"))
         store.set("MASTER_PORT", str(master_port).encode(encoding="UTF-8"))
@@ -545,7 +570,9 @@ def _rendezvous(self, worker_group: WorkerGroup) -> None:
         worker_group.group_world_size = group_world_size
 
         if group_rank == 0:
-            self._set_master_addr_port(store, spec.master_addr, spec.master_port)
+            self._set_master_addr_port(
+                store, spec.master_addr, spec.master_port, spec.endpoint
+            )
         master_addr, master_port = self._get_master_addr_port(store)
         restart_count = spec.max_restarts - self._remaining_restarts
 
@@ -781,7 +808,7 @@ def _construct_event(
             "group_rank": wg.group_rank,
             "worker_id": worker_id,
             "role": spec.role,
-            "hostname": _get_fq_hostname(),
+            "hostname": _get_fq_hostname(spec.master_addr, spec.endpoint),
             "state": state,
             "total_run_time": self._total_execution_time,
             "rdzv_backend": spec.rdzv_handler.get_backend(),
diff --git a/torch/distributed/launcher/api.py b/torch/distributed/launcher/api.py
index b09a31250f2a..c042460a50a2 100644
--- a/torch/distributed/launcher/api.py
+++ b/torch/distributed/launcher/api.py
@@ -224,6 +224,7 @@ def launch_agent(
         tee=config.tee,
         master_addr=master_addr,
         master_port=master_port,
+        endpoint=rdzv_parameters.endpoint.strip(),
     )
 
     agent = LocalElasticAgent(

From f982f75fb111a91c2e4e32915cba68b8c5699bbb Mon Sep 17 00:00:00 2001
From: janEbert <janpublicebert@posteo.net>
Date: Tue, 19 Jul 2022 12:39:41 +0200
Subject: [PATCH 3/3] Also check FQDN of host for machine match test

"Host" refers to the host given via the `--rdzv_endpoint` argument.

This catches cases where users specify a non-fully-qualified name.
---
 torch/distributed/elastic/rendezvous/utils.py | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/torch/distributed/elastic/rendezvous/utils.py b/torch/distributed/elastic/rendezvous/utils.py
index b838398549d1..187e986f9ffa 100644
--- a/torch/distributed/elastic/rendezvous/utils.py
+++ b/torch/distributed/elastic/rendezvous/utils.py
@@ -164,12 +164,13 @@ def _matches_machine_hostname(host: str) -> bool:
     if host == this_host:
         return True
 
+    host_fqdn = socket.getfqdn(host)
     addr_list = socket.getaddrinfo(
         this_host, None, proto=socket.IPPROTO_TCP, flags=socket.AI_CANONNAME
     )
     for addr_info in addr_list:
         # If we have an FQDN in the addr_info, compare it to `host`.
-        if addr_info[3] and addr_info[3] == host:
+        if addr_info[3] and (addr_info[3] == host or addr_info[3] == host_fqdn):
             return True
         # Otherwise if `host` represents an IP address, compare it to our IP
         # address.
@@ -177,7 +178,10 @@ def _matches_machine_hostname(host: str) -> bool:
             return True
 
     for (nic_host, nic_addr) in nic_info():
-        if nic_host == host or addr and nic_addr == str(addr):
+        if (
+                nic_host == host or nic_host == host_fqdn
+                or addr and nic_addr == str(addr)
+        ):
             return True
 
     return False